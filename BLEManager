//
//  BLEManager.swift
//  EMG-ble-kth
//

import Foundation
import CoreBluetooth
import QuartzCore // for time
import SwiftUI // Required for Alert
import UIKit  // Required for background execution

struct TimestampedData: Comparable {
    let timestamp: CFTimeInterval
    let values: [Float]
    
    // Conform to Comparable
    static func < (lhs: TimestampedData, rhs: TimestampedData) -> Bool {
        return lhs.timestamp < rhs.timestamp
    }

    static func == (lhs: TimestampedData, rhs: TimestampedData) -> Bool {
        return lhs.timestamp == rhs.timestamp
    }
}

struct Peripheral: Identifiable {
    let id: Int
    let name: String
    let rssi: Int
}

// Priority Queue Implementation
struct PriorityQueue<T: Comparable> {
    private var heap: [T]
    private let ordered: (T, T) -> Bool

    init(ascending: Bool = true, startingValues: [T] = []) {
        self.ordered = ascending ? { $0 < $1 } : { $0 > $1 }
        self.heap = startingValues
        buildHeap()
    }

    private mutating func buildHeap() {
        for index in stride(from: (heap.count / 2 - 1), through: 0, by: -1) {
            heapifyDown(from: index)
        }
    }

    var count: Int { heap.count }
    var isEmpty: Bool { heap.isEmpty }

    mutating func push(_ element: T) {
        heap.append(element)
        heapifyUp(from: heap.count - 1)
    }

    mutating func pop() -> T? {
        guard !heap.isEmpty else { return nil }
        heap.swapAt(0, heap.count - 1)
        let popped = heap.removeLast()
        heapifyDown(from: 0)
        return popped
    }

    private mutating func heapifyUp(from index: Int) {
        var child = index
        var parent = (child - 1) / 2
        while child > 0 && ordered(heap[child], heap[parent]) {
            heap.swapAt(child, parent)
            child = parent
            parent = (child - 1) / 2
        }
    }

    private mutating func heapifyDown(from index: Int) {
        var parent = index
        while true {
            let left = 2 * parent + 1
            let right = 2 * parent + 2
            var candidate = parent

            if left < heap.count && ordered(heap[left], heap[candidate]) {
                candidate = left
            }
            if right < heap.count && ordered(heap[right], heap[candidate]) {
                candidate = right
            }
            if candidate == parent { return }
            heap.swapAt(parent, candidate)
            parent = candidate
        }
    }

    func peek() -> T? {
        return heap.first
    }
}

class BLEManager: NSObject, ObservableObject, CBCentralManagerDelegate {
    var myCentral: CBCentralManager!
    @Published var BLEisOn = false
    @Published var BLEPeripherals = [Peripheral]()
    @Published var isConnected = false
    
    // Track when the last log was printed
    private var lastSkippedLogTime: CFTimeInterval = CACurrentMediaTime()
    
    var CBPeripherals = [CBPeripheral]()
    var emgCharacteristic: CBCharacteristic?
    var emg: emgGraph
    private var droppedPackets: Int = 0
    private var totalPackets: Int = 0
    private let packetLossThreshold: Float = 0.1 // 10% packet loss threshold
    
    
    // RMS Buffers and Calculation
    private var emgBuffer: [Float] = [] // Buffer for 0.1-second RMS calculation
    private let windowSize = 1 // 0.1 seconds at 10 Hz sampling rate
    @Published var currentRMS: Float = 0.0 // Latest 0.1-second RMS
    @Published var rmsHistory: [Float] = [] // Store historical 0.1-second RMS values
    
    private var oneSecondBuffer: [Float] = [] // Buffer for 1-second RMS calculation
    private let oneSecondWindowSize = 10 // 1 second at 10 Hz sampling rate
    @Published var oneSecondRMS: Float = 0.0 // Latest 1-second RMS
    
    ///process BLE data in the background
    private let dataQueue = DispatchQueue(label: "com.emg.ble.data")
    
    var notificationTimestamps: [CFTimeInterval] = [] // Stores timestamps for debugging
    var notificationSamples: [Int] = [] // Stores sample counts per notification
    
    var firstSampleTimestamp: CFTimeInterval? // Stores first timestamp as reference
    var expectedNextTimestamp: CFTimeInterval? // Expected timestamp for next sample
    
    private var receivedValuesPerTimestamp: [CFTimeInterval: [Float]] = [:] // Rolling buffer for tracking received values
    private let rollingBufferLimit = 700 // Stores data for the last 10 seconds (assuming 10 Hz updates)
    
    var reconnectionAttempts: Int = 0
    let maxReconnectionAttempts = 2
    
    // Declare total packets received and expected
    private var totalPacketsReceived = 0
    private var totalPacketsExpected = 0
    
    // calculaate adquisiton ratio variables
    private var lastSARUpdateTime: CFTimeInterval = CACurrentMediaTime()
    private var lastPrintTime: CFTimeInterval = CACurrentMediaTime()
    private var lastSARValue: Double = 100.0
    
    // Buffer for storing EMG data with timestamps (each entry includes data and the timestamp)
    private var timestampBuffer = PriorityQueue<TimestampedData>(ascending: true, startingValues: [])
    private let bufferLimit = 500 // Limit the buffer size to 500 values, in case  data comes in bursts
    
    ///process BLE data in the background
    private let emgProcessingQueue = DispatchQueue(label: "com.emg.processing", qos: .userInitiated)
    var backgroundTask: UIBackgroundTaskIdentifier = .invalid
    
    //disconnect device
    @Published var connectionErrorMessage: String? = nil
    @Published var showAlert = false // Controls the visibility of the alert
    @Published var alertMessage = "" // Stores the alert message
    //moving average timestamp normalization
    private var timestampOffsetBuffer: [CFTimeInterval] = []
    
    
    var startTime: CFTimeInterval? // Holds the timestamp when first packet arrives

    
    init(emg: emgGraph) {
        self.emg = emg
        super.init()
        
        // Create a background queue for BLE operations
        let backgroundQueue = DispatchQueue.global(qos: .background)
        myCentral = CBCentralManager(delegate: self, queue: backgroundQueue)
    }
    // background task app for maintaining connections active after locking down cellphone
    func beginBackgroundTask() {
        backgroundTask = UIApplication.shared.beginBackgroundTask {
            print("‚ö†Ô∏è Background task expired.")
            UIApplication.shared.endBackgroundTask(self.backgroundTask)
            self.backgroundTask = .invalid
        }
    }
    
    func endBackgroundTask() {
        UIApplication.shared.endBackgroundTask(backgroundTask)
        backgroundTask = .invalid
    }
    
    func centralManagerDidUpdateState(_ central: CBCentralManager) {
        DispatchQueue.main.async {
            self.BLEisOn = (central.state == .poweredOn)
            
            if central.state == .poweredOn {
                // ‚úÖ Restart scanning in the background
                self.startScanning()
            } else {
                print("‚ö†Ô∏è Bluetooth is off, cannot scan.")
            }
        }
    }
    
    func checkBluetoothStatus() {
        if !BLEisOn {
            print("‚ö†Ô∏è Bluetooth is not on. Please enable Bluetooth.")
            return
        }
    }
    
    func checkBluetoothPermissions() {
        switch CBManager.authorization {
        case .allowedAlways:
            print("Bluetooth is allowed")
        case .restricted, .denied:
            print("Bluetooth access denied")
        default:
            print("Bluetooth authorization pending")
        }
    }
    
    func startScanning() {
        guard !isConnected else {
            print("üîπ Already connected, skipping scanning.")
            return
        }
        print("üîç Start Scanning")
        
        DispatchQueue.main.async {
            self.BLEPeripherals.removeAll()  // ‚úÖ Clear ghost sensors before scanning
            self.CBPeripherals.removeAll()
        }
        
        myCentral.scanForPeripherals(withServices: nil, options: nil)
    }
    
    
    func stopScanning() {
        print("Stop Scanning")
        myCentral.stopScan()
    }
    
    func connectSensor(p: Peripheral) {
        // Check Bluetooth status before attempting connection
        checkBluetoothStatus()
        
        // Ensure we're not already connected and the peripheral exists
        guard p.id < CBPeripherals.count, !isConnected else {
            print("üîπ Already connected, skipping connection attempt.")
            return
        }
        // Reset the reconnection attempts when manually reconnecting
        self.reconnectionAttempts = 0
        
        // Stop scanning if we're currently scanning
        if myCentral.isScanning {
            myCentral.stopScan()
        }
        
        // Debugging log for the connection attempt
        print("üîÑ Connecting to: \(CBPeripherals[p.id].name ?? "Unknown")")
        
        // Get the peripheral we're trying to connect to
        let peripheral = CBPeripherals[p.id]
        myCentral.connect(peripheral, options: nil)
        
        // Safety timeout: If the connection hasn't succeeded in 5 seconds, cancel and retry
        DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 10.0) {
            if !self.isConnected {
                // Timeout reached, cancel connection attempt
                print("‚ùå Connection attempt timed out. Cancelling attempt and retrying.")
                self.myCentral.cancelPeripheralConnection(peripheral)
                
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                    // If there are more reconnection attempts left, try reconnecting
                    if self.reconnectionAttempts < self.maxReconnectionAttempts {
                        self.reconnectionAttempts += 1
                        print("üîÑ Retrying reconnection (\(self.reconnectionAttempts)/\(self.maxReconnectionAttempts))...")
                        self.myCentral.connect(peripheral, options: nil)
                    } else {
                        // Max attempts reached, stop retrying
                        print("üî¥ Max reconnection attempts reached. Stopping reconnection.")
                        self.alertMessage = "Check device battery and Bluetooth stability."
                        self.showAlert = true
                    }
                }
            }
        }
    }
    
    
    // Connecting to the correct device - ANR Corp
    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String: Any], rssi RSSI: NSNumber) {
        if let manufacturerData = advertisementData[CBAdvertisementDataManufacturerDataKey] as? Data,
           manufacturerData.count >= 2 {
            let companyID = UInt16(manufacturerData[1]) << 8 | UInt16(manufacturerData[0]) // Little-endian
            if companyID != 0x05DA {
                let now = CACurrentMediaTime()
                if now - lastSkippedLogTime > 5.0 {  // ‚úÖ Print log only every 5 seconds
                    print("Skipping non-ANR device")
                    lastSkippedLogTime = now  // Update last log time
                }
                return
            }
        } else {
            let now = CACurrentMediaTime()
            if now - lastSkippedLogTime > 5.0 {  // ‚úÖ Print log only every 5 seconds
                print("No Manufacturer Specific Data found, skipping device.")
                lastSkippedLogTime = now
            }
            return
        }
        
        let peripheralName = advertisementData[CBAdvertisementDataLocalNameKey] as? String ?? "Unknown"
        print("Discovered device: \(peripheralName) with RSSI: \(RSSI.intValue)")
        
        let newPeripheral = Peripheral(id: BLEPeripherals.count, name: peripheralName, rssi: RSSI.intValue)
        DispatchQueue.main.async {
            self.BLEPeripherals.append(newPeripheral)
        }
        CBPeripherals.append(peripheral)
    }
    
    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
        print("‚úÖ Connected to \(peripheral.name ?? "Unknown Device")")
        
        DispatchQueue.main.async {
            self.isConnected = true
        }
        
        myCentral.stopScan()
        
        // ‚úÖ Assign delegate to the peripheral (moved outside condition)
        peripheral.delegate = self
        
        // ‚úÖ Discover services
        peripheral.discoverServices(nil)
        
        // ‚úÖ Ensure notifications remain active after connection
        if let emgCharacteristic = self.emgCharacteristic {
            peripheral.setNotifyValue(true, for: emgCharacteristic)
            print("‚úÖ Notifications re-enabled for \(emgCharacteristic.uuid)")
        } else {
            print("‚ö†Ô∏è No EMG characteristic found yet. Waiting for discovery...")
        }
    }
    
    
    
    // if the device is disconnected wait 1 second and try to restablish connection
    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
        print("‚ùå Disconnected from \(peripheral.name ?? "Unknown Device")")
        
        // Update UI to reflect the disconnected state
        DispatchQueue.main.async {
            self.isConnected = false
        }
        
        // Prevent data loss by keeping recent timestamps
        DispatchQueue.global(qos: .background).async {
            self.receivedValuesPerTimestamp = self.receivedValuesPerTimestamp.filter { CACurrentMediaTime() - $0.key < 5 }
            print("üîÑ Keeping only recent timestamps to prevent data loss after reconnection")
        }
        // Prevent infinite reconnection attempts
        if reconnectionAttempts >= maxReconnectionAttempts {
            print("üî¥ Max reconnection attempts reached. Stopping reconnection.")
            
            // Show alert when max reconnection attempts are reached
            DispatchQueue.main.async {
                self.alertMessage = "Max reconnection attempts reached. Verify Bluetooth connection and device battery."
                self.showAlert = true
                
            }
            return
        }
        // Increment reconnection attempt counter
        reconnectionAttempts += 1
        print("üîÑ Attempting to reconnect (\(reconnectionAttempts)/\(maxReconnectionAttempts))...")
        
        // Prevent duplicate reconnection logs
        if reconnectionAttempts == 1 {
            print("üîÑ First reconnection attempt. Initiating reconnection sequence.")
        } else {
            print("‚ö†Ô∏è Reconnection attempt (\(reconnectionAttempts)/\(maxReconnectionAttempts)) in progress...")
        }
        // Reduce wait time for faster reconnection (5 seconds before retry)
        DispatchQueue.global(qos: .background).asyncAfter(deadline: .now() + 5.0) {
            self.myCentral.connect(peripheral, options: nil)
        }
        // Trigger the UI to reflect ongoing reconnection attempts
        DispatchQueue.main.async {
            // Update the alert message to show reconnection attempts in progress
            self.alertMessage = "Attempting to reconnect... (\(self.reconnectionAttempts)/\(self.maxReconnectionAttempts))"
            self.showAlert = true
        }
    }
    
    // SAR
    func calculateSignalAcquisitionRatio() {
        let now = CACurrentMediaTime()
        
        // Ensure SAR calculation only happens once per second
        if now - lastSARUpdateTime < 1.0 { return }
        
        let sar = (totalPacketsReceived > 0) ? (Double(totalPacketsReceived) / Double(totalPacketsExpected)) * 100 : 0.0
        lastSARUpdateTime = now
        
        // Print logic based on SAR value:
        if sar == 100.0 {
            if lastSARValue != 100.0 || now - lastPrintTime >= 10.0 {
                print("üì° Signal Acquisition Ratio (SAR): \(sar)% ‚úÖ (Perfect signal)")
                lastPrintTime = now
            }
        } else if sar < 10.0 {
            // If SAR is below 10%, print every cycle until it reaches 80%
            print("‚ö†Ô∏è Low Signal Acquisition Ratio (SAR): \(sar)% ‚ùå - Check connection")
            lastPrintTime = now
        } else if sar < 80.0 {
            // Continue printing every cycle until SAR is 80%
            print("‚ö†Ô∏è SAR Recovering: \(sar)%")
            lastPrintTime = now
        } else {
            // Normal case: Print every second
            if now - lastPrintTime >= 1.0 {
                print("üì° Signal Acquisition Ratio (SAR): \(sar)%")
                lastPrintTime = now
            }
        }
        
        lastSARValue = sar
    }
    func normalizeTimestamp(_ timestamp: CFTimeInterval, precision: Int = 1) -> CFTimeInterval {
        let multiplier = pow(10.0, Double(precision))
        let roundedTimestamp = round(timestamp * multiplier) / multiplier
        
        // ‚úÖ Moving average timestamp correction
        timestampOffsetBuffer.append(roundedTimestamp)
        if timestampOffsetBuffer.count > 10 {
            timestampOffsetBuffer.removeFirst()
        }
        
        let correctedTimestamp = timestampOffsetBuffer.reduce(0, +) / Double(timestampOffsetBuffer.count)
        return correctedTimestamp
    }
    
    func processAndAppendEMGData(_ rawEMGData: [Float], timestamp: CFTimeInterval) {
        totalPackets += 1
        if rawEMGData.isEmpty {
            droppedPackets += 1
        }

        // ‚úÖ Use a larger rolling buffer to prevent early removals
        timestampBuffer.push(TimestampedData(timestamp: timestamp, values: rawEMGData.isEmpty ? [0.001] : rawEMGData))

        // ‚úÖ Only remove excess timestamps beyond `bufferLimit`
        while timestampBuffer.count > bufferLimit {
            _ = timestampBuffer.pop() // Remove oldest data only if exceeding safe limit
        }

        // ‚úÖ Ensure the data is sanitized before appending
        let sanitizedData: [Float] = rawEMGData.isEmpty ? [0.001] : rawEMGData.map { $0.isFinite ? $0 : 0.0 }
        let sanitizedCGFloatData = sanitizedData.map { CGFloat($0) }

        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            let normalizedTimestamp = self.normalizeTimestamp(timestamp)

            // ‚úÖ Check for large gaps in timestamps
            if let lastTimestamp = self.emg.timestamps.last {
                let timeGap = normalizedTimestamp - lastTimestamp
                if timeGap > 0.2 {
                    print("‚ö†Ô∏è Large gap detected in timestamps! Filling missing data.")
                    var tempTimestamp = lastTimestamp + 0.1
                    while tempTimestamp < normalizedTimestamp {
                        self.emg.append(values: [0.001], timestamp: tempTimestamp)
                        tempTimestamp += 0.1
                    }
                }
            }
            

            // ‚úÖ Append sanitized data only once (fixed potential duplicate call)
           // print("üì° BLE Data Received: \(sanitizedCGFloatData.count) values, latest timestamp: \(timestamp)")

            if !self.emg.timestamps.isEmpty {
            }

            self.emg.append(values: sanitizedCGFloatData, timestamp: normalizedTimestamp)
        }
    }    
    
    // interpolation when packet lost and under adquisiton ratio is 10%
    func reconstructDataStream() {
        guard droppedPackets > 0, Float(droppedPackets) / Float(totalPackets) > packetLossThreshold else {
            return
        }
        print("üîÑ Buffer before reconstruction: \(timestampBuffer.count) samples")

        var reconstructedData: [TimestampedData] = []
        while let entry = timestampBuffer.pop() {
            if !reconstructedData.isEmpty {
                let previous = reconstructedData.last!
                let gap = entry.timestamp - previous.timestamp
                
                if gap > 0.1 { // Missing data detected
                    let interpolatedValue = (entry.values.first! + previous.values.first!) / 2
                    let interpolatedTimestamp = previous.timestamp + 0.1
                    reconstructedData.append(TimestampedData(timestamp: interpolatedTimestamp, values: [interpolatedValue]))
                }
            }
            reconstructedData.append(entry)
        }

        // Push reconstructed data back
        for entry in reconstructedData {
            timestampBuffer.push(entry)
        }
    }

    func updateShortTermRMS(with newValues: [Float]) {
        dataQueue.async { [weak self] in
            guard let self = self else { return }
            let validValues = newValues.filter { $0.isFinite }
            self.emgBuffer.append(contentsOf: validValues)
            let rmsDelta = self.calculateRMS(from: validValues)
            self.currentRMS = sqrt(pow(self.currentRMS, 2) * Float(self.emgBuffer.count - validValues.count) + pow(rmsDelta, 2)) / Float(self.emgBuffer.count)
        }
    }


    func calculateRMS(from samples: [Float]) -> Float {
        let validSamples = samples.filter { $0.isFinite }
        guard !validSamples.isEmpty else { return 0.0 }
        let squaredSum = validSamples.reduce(0.0) { $0 + $1 * $1 }
        return sqrt(squaredSum / Float(validSamples.count))
    }
}

extension BLEManager: CBPeripheralDelegate {
    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
        guard let services = peripheral.services else { return }
        for service in services {
            peripheral.discoverCharacteristics(nil, for: service)
        }
    }

    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
        if let characteristics = service.characteristics {
            for characteristic in characteristics {
                if characteristic.uuid == CBUUID(string: "2A58") { // Change to the actual UUID of your EMG characteristic
                    self.emgCharacteristic = characteristic
                    peripheral.setNotifyValue(true, for: characteristic) // Enable notifications
                    print("‚úÖ EMG Characteristic Found: \(characteristic.uuid)")
                }
            }
        }
    }

    func detectLostPackets(currentTimestamp: CFTimeInterval, previousTimestamp: CFTimeInterval?) {
        guard let lastTimestamp = previousTimestamp else { return }
        let expectedNextTimestamp = lastTimestamp + 0.1

        let timeDifference = abs(currentTimestamp - expectedNextTimestamp)

        // ‚úÖ Adaptive packet loss detection
        let adjustedThreshold = max(0.05, min(0.2, Float(droppedPackets) / Float(totalPackets))) // Adjust threshold dynamically

        if timeDifference > Double(adjustedThreshold) {
            print("‚ö†Ô∏è Packet loss detected! Expected: \(expectedNextTimestamp), Received: \(currentTimestamp)")
            fillMissingPackets(from: lastTimestamp, to: currentTimestamp)
        }
    }


    func fillMissingPackets(from lastTimestamp: CFTimeInterval, to newTimestamp: CFTimeInterval) {
        var missingTimestamp = lastTimestamp + 0.1
        while missingTimestamp < newTimestamp {
            print("‚ö†Ô∏è Filling missing packet at \(missingTimestamp)")
            emg.append(values: [0.0], timestamp: missingTimestamp)
            missingTimestamp += 0.1
        }
    }

    func fillMissingPacketsWithInterpolation(from lastTimestamp: CFTimeInterval, lastValue: CGFloat,
                                             to newTimestamp: CFTimeInterval, newValue: CGFloat) {
        var missingTimestamps: [CFTimeInterval] = []
        var tempTimestamp = lastTimestamp + 0.1

        while tempTimestamp < newTimestamp {
            missingTimestamps.append(tempTimestamp)
            tempTimestamp += 0.1
        }

        var interpolatedValues: [CGFloat]

        if missingTimestamps.count < 10 {
            // ‚úÖ Use smooth interpolation for small gaps
            interpolatedValues = cubicHermiteInterpolation(from: lastValue, to: newValue, timestamps: missingTimestamps)
        } else {
            // ‚úÖ Use last known value for large gaps to prevent artificial drift
            interpolatedValues = Array(repeating: lastValue, count: missingTimestamps.count)
        }

        for (index, timestamp) in missingTimestamps.enumerated() {
            print("üîÑ Interpolating Data: \(timestamp) -> \(interpolatedValues[index])")
            emg.append(values: [interpolatedValues[index]], timestamp: timestamp)
        }
    }

    /// üîπ Cubic Hermite Interpolation for Smooth Packet Loss Handling
    func cubicHermiteInterpolation(from previousValue: CGFloat, to nextValue: CGFloat, timestamps: [CFTimeInterval]) -> [CGFloat] {
        let tRange = timestamps.count + 1
        let step = 1.0 / CGFloat(tRange)

        return (1..<tRange).map { i in
            let t = CGFloat(i) * step
            let t2 = t * t
            let t3 = t2 * t

            return (2 * t3 - 3 * t2 + 1) * previousValue + (t3 - 2 * t2 + t) * 0 + (-2 * t3 + 3 * t2) * nextValue + (t3 - t2) * 0
        }
    }

    // **Improved Interpolation Function**
    func interpolateData(from previousValue: CGFloat, to nextValue: CGFloat, timestamps: [CFTimeInterval]) -> [CGFloat] {
        let step = (nextValue - previousValue) / CGFloat(timestamps.count + 1)
        return (1...timestamps.count).map { previousValue + (step * CGFloat($0)) }
    }

    
    

    // Packet loss handling and timastamps
    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
        // ‚úÖ Background task to allow processing when the app is in the background
        var backgroundTask: UIBackgroundTaskIdentifier?
        backgroundTask = UIApplication.shared.beginBackgroundTask(withName: "BLEDataProcessing") {
            print("‚ö†Ô∏è Background task expired.")
            if let task = backgroundTask {
                UIApplication.shared.endBackgroundTask(task)
            }
            backgroundTask = .invalid
        }

        guard let task = backgroundTask, task != .invalid else {
            print("‚ö†Ô∏è Failed to start background task.")
            return
        }

        defer {
            UIApplication.shared.endBackgroundTask(task)
            backgroundTask = .invalid
        }

        // ‚úÖ Error handling
        if let error = error {
            print("‚ùå Error updating value for characteristic: \(error.localizedDescription)")
            return
        }
        // ‚úÖ Track first timestamp when data arrives
        if startTime == nil {
            startTime = CACurrentMediaTime() // Save first timestamp
        }

        // ‚úÖ Check if we are within the first 5 seconds
        //if let startTime = startTime, CACurrentMediaTime() - startTime < 5 {
         //   print("‚è≥ Stabilization period active: Ignoring data for first 5 seconds.")
        //    return // Skip processing
      //  }


        switch characteristic.uuid {
        case CBUUID(string: "2A58"): // ‚úÖ EMG Data
            guard let characteristicData = characteristic.value, characteristicData.count % 2 == 0 else {
                print("‚ùå Error: Invalid EMG data length")
                return
            }

            let systemTimestamp = normalizeTimestamp(CACurrentMediaTime()) // ‚úÖ Ensure timestamp precision

            // ‚úÖ Extract EMG values efficiently
            var rawValues: [Float] = stride(from: 0, to: characteristicData.count, by: 2).map {
                let rawValue = UInt16(characteristicData[$0]) | (UInt16(characteristicData[$0 + 1]) << 8)
                return Float(rawValue) / 1000.0
            }

            // ‚úÖ Replace NaN values with 0.0
            rawValues = rawValues.map { $0.isFinite ? $0 : 0.0 }

            // ‚úÖ Initialize timestamps on first-time connection
            if firstSampleTimestamp == nil || expectedNextTimestamp == nil {
                firstSampleTimestamp = systemTimestamp
                expectedNextTimestamp = firstSampleTimestamp
                print("‚úÖ Initialized firstSampleTimestamp: \(firstSampleTimestamp!)")
            } else if abs(systemTimestamp - expectedNextTimestamp!) > 1.0 {
                print("‚ö†Ô∏è Large gap detected at start-up. Resetting expected timestamp.")
                expectedNextTimestamp = systemTimestamp
            }


            // ‚úÖ Detect & realign large timestamp gaps
            if abs(systemTimestamp - expectedNextTimestamp!) > 1.0 {
                print("‚ö†Ô∏è Large timestamp gap detected. Realigning...")
                expectedNextTimestamp = systemTimestamp
            }

            var timestamp: CFTimeInterval
            if let expectedTime = expectedNextTimestamp {
                
                let timeDifference = systemTimestamp - expectedTime
                if abs(timeDifference) > 0.8 {
                    print("‚ö†Ô∏è Packet loss detected! Performing interpolation.")
                    fillMissingPacketsWithInterpolation(from: expectedTime,
                                                        lastValue: CGFloat(rawValues.first ?? 0.0),
                                                        to: systemTimestamp,
                                                        newValue: CGFloat(rawValues.first ?? 0.0))

                }

                timestamp = normalizeTimestamp(expectedTime)
                expectedNextTimestamp = expectedTime + 0.1
            } else {
                timestamp = normalizeTimestamp(systemTimestamp)
                expectedNextTimestamp = systemTimestamp + 0.1
            }

            // ‚úÖ Store received values in the buffer
            receivedValuesPerTimestamp[timestamp] = rawValues
            totalPacketsReceived += 1
            totalPacketsExpected += 1

            // ‚úÖ More efficient buffer cleanup (prevents overflow)
            if receivedValuesPerTimestamp.count >= rollingBufferLimit {
                receivedValuesPerTimestamp.removeValue(forKey: receivedValuesPerTimestamp.keys.min()!)
            }

         //   print("üìä Timestamp: \(timestamp) | Received \(rawValues.count) EMG samples")
            
            // ‚úÖ Process & Append EMG data
            calculateSignalAcquisitionRatio()
            reconstructDataStream()
            DispatchQueue.main.async {
                self.processAndAppendEMGData(rawValues, timestamp: timestamp)
            }

        default:
            print("‚ö†Ô∏è Unhandled characteristic UUID: \(characteristic.uuid)")
        }
    }
}


